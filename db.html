
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>db</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("db");</script>
	<table class="content">
		<tr><td id="docbody"><h1>db</h1><!-- Generated by Ddoc from db.d -->
Common relational database interfaces.
<br><br>
<b>License:</b><br>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Piotr Szturmaj<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">DBRow</span>
<script>explorer.outline.addDecl('DBRow');</script>

(Specs...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Data row returned from database servers.
<br><br>

<span class="currsymbol">DBRow</span>
<script>explorer.outline.addDecl('DBRow');</script>

 may be instantiated with any number of arguments. It subtypes base type which
depends on that number:
<br><br>

<table>   <tr><th>Number of arguments</th> <th>Base type</th></tr>
    <tr><td>0</td> <td>Variant[] <br><br>
    It is default dynamic row, which can handle arbitrary number of columns and any of their types.
    </td></tr>
    <tr><td>1</td> <td>Specs itself, more precisely Specs[0] <br>
<pre class="d_code">    <font color=blue>struct</font> S { <font color=blue>int</font> i, <font color=blue>float</font> f }

    <u>DBRow</u>!<font color=blue>int</font> rowInt;
    <u>DBRow</u>!S rowS;
    <u>DBRow</u>!(Tuple!(string, <font color=blue>bool</font>)) rowTuple;
    <u>DBRow</u>!(<font color=blue>int</font>[10]) rowSA;
    <u>DBRow</u>!(<font color=blue>bool</font>[]) rowDA;
</pre>
    </td></tr>
    <tr><td>&gt;= 2</td> <td>Tuple!Specs <br>
<pre class="d_code">    <u>DBRow</u>!(<font color=blue>int</font>, string) row1; <font color=green>// two arguments
</font>    <u>DBRow</u>!(<font color=blue>int</font>, <font color=red>"i"</font>) row2; <font color=green>// two arguments
</font></pre>
    </td></tr>
</table>
<br><br>

If there is only one argument, the semantics depend on its type:
<br><br>

<table>   <tr><th>Type</th> <th>Semantics</th></tr>
    <tr><td>base type, such as int</td> <td>Row contains only one column of that type</td></tr>
    <tr><td>struct</td> <td>Row columns are mapped to fields of the struct in the same order</td></tr>
    <tr><td>Tuple</td> <td>Row columns are mapped to tuple fields in the same order</td></tr>
    <tr><td>static array</td> <td>Row columns are mapped to array items, they share the same type</td></tr>
    <tr><td>dynamic array</td> <td>Same as static array, except that column count may change during runtime</td></tr>
</table>
<br><br>
<b>Note:</b><br>
String types are treated as base types.
<br><br>

There is an exception for RDBMSes which are capable of returning arrays and/or composite types. If such a
database server returns array or composite in one column it may be mapped to 
<span class="currsymbol">DBRow</span>
<script>explorer.outline.addDecl('DBRow');</script>

 as if it was many columns.
For example:
<pre class="d_code"><font color=blue>struct</font> S { string field1; <font color=blue>int</font> field2; }
<u>DBRow</u>!S row;
</pre>
In this case row may handle result that either:
<ul>   <li>has two columns convertible to respectively, string and int</li>
    <li>has one column with composite type compatible with S</li>
</ul>

<br><br>
<b>Examples:</b><br>
Default untyped (dynamic) DBRow:
<pre class="d_code"><u>DBRow</u>!() row1;
<u>DBRow</u>!(Variant[]) row2;

<font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(row1.base == row2.base)));
</pre>
DBRow with only one field:
<pre class="d_code"><u>DBRow</u>!<font color=blue>int</font> row;
row = 10;
row += 1;
<font color=blue>assert</font>(row == 11);

<u>DBRow</u>!Variant untypedRow;
untypedRow = 10;
</pre>
DBRow with more than one field:
<pre class="d_code"><font color=blue>struct</font> S { <font color=blue>int</font> i; string s; }
<font color=blue>alias</font> Tuple!(<font color=blue>int</font>, <font color=red>"i"</font>, string, <font color=red>"s"</font>) TS;

<font color=green>// all three rows are compatible
</font><u>DBRow</u>!S row1;
<u>DBRow</u>!TS row2;
<u>DBRow</u>!(<font color=blue>int</font>, <font color=red>"i"</font>, string, <font color=red>"s"</font>) row3;

row1.i = row2.i = row3.i = 10;
row1.s = row2.s = row3.s = <font color=red>"abc"</font>;

<font color=green>// these two rows are also compatible
</font><u>DBRow</u>!(<font color=blue>int</font>, <font color=blue>int</font>) row4;
<u>DBRow</u>!(<font color=blue>int</font>[2]) row5;

row4[0] = row5[0] = 10;
row4[1] = row5[1] = 20;
</pre>
Advanced example:
<pre class="d_code"><font color=blue>enum</font> Axis { x, y, z }
<font color=blue>struct</font> SubRow1 { string s; <font color=blue>int</font>[] nums; <font color=blue>int</font> num; }
<font color=blue>alias</font> Tuple!(<font color=blue>int</font>, <font color=red>"num"</font>, string, <font color=red>"s"</font>) SubRow2;
<font color=blue>struct</font> Row { SubRow1 left; SubRow2[] right; Axis axis; string text; }

<font color=blue>auto</font> cmd = <font color=blue>new</font> PGCommand(conn, <font color=red>"SELECT ROW('text', ARRAY[1, 2, 3], 100),
                                ARRAY[ROW(1, 'str'), ROW(2, 'aab')], 'x', 'anotherText'"</font>);

<font color=blue>auto</font> row = cmd.executeRow!Row;

<font color=blue>assert</font>(row.left.s == <font color=red>"text"</font>);
<font color=blue>assert</font>(row.left.nums == [1, 2, 3]);
<font color=blue>assert</font>(row.left.num == 100);
<font color=blue>assert</font>(row.right[0].num == 1 &amp;&amp; row.right[0].s == <font color=red>"str"</font>);
<font color=blue>assert</font>(row.right[1].num == 2 &amp;&amp; row.right[1].s == <font color=red>"aab"</font>);
<font color=blue>assert</font>(row.axis == Axis.x);
<font color=blue>assert</font>(row.s == <font color=red>"anotherText"</font>);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">checkReceivedFieldCount</span>
<script>explorer.outline.addDecl('checkReceivedFieldCount');</script>

(int <span class="funcparam">fieldCount</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks if received field count matches field count of this row type.
<br><br>
This is used internally by clients and it applies only to DBRow types, which have static number of fields.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isCompositeType</span>
<script>explorer.outline.addDecl('isCompositeType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Check if type is a composite.
<br><br>
Composite is a type with static number of fields. These types are:
<ul>   <li>Tuples</li>
    <li>structs</li>
    <li>static arrays</li>
</ul><br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Apr  3 18:26:49 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule(".db"); 
    explorer.packageExplorer.addModule(".postgres"); </script>
</body></html>


